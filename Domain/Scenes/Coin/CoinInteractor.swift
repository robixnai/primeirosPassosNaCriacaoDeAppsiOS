//
//  CoinInteractor.swift
//  MarketCoins
//
//  Created by Robson Moreira on 07/11/22.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Charts

protocol CoinBusinessLogic {
    func doFetchCurrentData(request: Coin.FetchCurrentData.Request)
    func doFetchMarketChart(request: Coin.FetchMarketChart.Request)
    func doFetchOhlc(request: Coin.FetchOhlc.Request)
}

protocol CoinDataStore {
    var coin: CoinModel? { get set }
}

class CoinInteractor: CoinBusinessLogic, CoinDataStore {
    
    var presenter: CoinPresentationLogic?
    var coinWorker: CoinWorker?
    var marketChartDataWorker: MarketChartDataWorker?
    var ohlcWorker: OHLCWorker?
    var coin: CoinModel?
    
    init(presenter: CoinPresentationLogic? = CoinPresenter(),
         coinWorker: CoinWorker? = CoinWorker(),
         marketChartDataWorker: MarketChartDataWorker = MarketChartDataWorker(),
         ohlcWorker: OHLCWorker = OHLCWorker()) {
        
        self.presenter = presenter
        self.coinWorker = coinWorker
        self.marketChartDataWorker = marketChartDataWorker
        self.ohlcWorker = ohlcWorker
    }
    
    // MARK: Do something
    
    func doFetchCurrentData(request: Coin.FetchCurrentData.Request) {
        guard let coinId = coin?.id else {
            presenter?.presentError(error: .undefinedError)
            return
        }
        
        coinWorker?.doFetchCurrentData(id: coinId, completion: { result in
            switch result {
            case .success(let currentDataModel):
                self.createCurrentDataResponse(baseCoin: request.baseCoin, currentData: currentDataModel)
            case .failure(let erro):
                self.presenter?.presentError(error: erro)
            }
        })
    }
    
    func doFetchMarketChart(request: Coin.FetchMarketChart.Request) {
        guard let coinId = coin?.id else {
            presenter?.presentError(error: .undefinedError)
            return
        }
        
        let baseCoin = request.baseCoin.rawValue
        let from = "\(Int(request.from.timeIntervalSince1970))"
        let to = "\(Int(request.to.timeIntervalSince1970))"
        
        marketChartDataWorker?.doFetchMarketChart(id: coinId, baseCoin: baseCoin, from: from, to: to, completion: { result in
            switch result {
            case .success(let marketDataModel):
                self.createMarketChartResponse(marketChart: marketDataModel)
            case .failure(let erro):
                self.presenter?.presentError(error: erro)
            }
        })
    }
    
    func doFetchOhlc(request: Coin.FetchOhlc.Request) {
        guard let coinId = coin?.id else {
            presenter?.presentError(error: .undefinedError)
            return
        }
        
        let baseCoin = request.baseCoin.rawValue
        let day = request.day
        
        ohlcWorker?.doFetchMarketChart(id: coinId, baseCoin: baseCoin, of: day, completion: { result in
            switch result {
            case .success(let graphicDataModel):
                self.createOhlcResponse(graphicData: graphicDataModel)
            case .failure(let erro):
                self.presenter?.presentError(error: erro)
            }
        })
    }
    
    private func createCurrentDataResponse(baseCoin: CoinsFilterEnum, currentData: CurrentDataModel?) {
        if let currentData {
            let response = Coin.FetchCurrentData.Response(
                baseCoin: baseCoin,
                currentPrice: currentData.marketData.currentPrice[baseCoin.rawValue] ?? 0.0,
                priceChangePercentage: currentData.marketData.priceChangePercentage1HInCurrency[baseCoin.rawValue] ?? 0.0,
                coinName: currentData.name,
                coinSymbol: currentData.symbol,
                coinImage: currentData.image.small,
                currentPriceComparationToCoin: currentData.marketData.currentPrice[baseCoin.rawValue] ?? 0.0,
                comparationToCoinSymbol: baseCoin.symbol,
                priceChangePercentageOneDay: currentData.marketData.priceChangePercentage24HInCurrency[baseCoin.rawValue] ?? 0.0,
                priceChangePercentageOneWeek: currentData.marketData.priceChangePercentage7DInCurrency[baseCoin.rawValue] ?? 0.0,
                priceChangePercentageTwoWeeks: currentData.marketData.priceChangePercentage14DInCurrency[baseCoin.rawValue] ?? 0.0,
                priceChangePercentageOneMonth: currentData.marketData.priceChangePercentage30DInCurrency[baseCoin.rawValue] ?? 0.0,
                priceChangePercentageTwoMonths: currentData.marketData.priceChangePercentage60DInCurrency[baseCoin.rawValue] ?? 0.0,
                priceChangePercentageOneYear: currentData.marketData.priceChangePercentage1yInCurrency[baseCoin.rawValue] ?? 0.0,
                marketCapRank: currentData.marketCapRank ?? 0,
                marketCap: currentData.marketData.marketCap[baseCoin.rawValue] ?? 0.0,
                fullyDilutedValuation: currentData.marketData.fullyDilutedValuation[baseCoin.rawValue] ?? 0.0,
                totalVolume: currentData.marketData.totalVolume[baseCoin.rawValue] ?? 0.0,
                high24h: currentData.marketData.high24h[baseCoin.rawValue] ?? 0.0,
                low24h: currentData.marketData.low24h[baseCoin.rawValue] ?? 0.0,
                supplyAvailable: currentData.marketData.circulatingsupply,
                totalSupply: currentData.marketData.totalSupply ?? 0.0,
                maxSupply: currentData.marketData.maxSupply ?? 0.0,
                maximumValue: currentData.marketData.ath[baseCoin.rawValue] ?? 0.0,
                maximumValuePercentage: currentData.marketData.athChangePercentage[baseCoin.rawValue] ?? 0.0,
                maximumValueDate: currentData.marketData.athDate[baseCoin.rawValue] ?? Date(),
                minimumValue: currentData.marketData.atl[baseCoin.rawValue] ?? 0.0,
                minimumValuePercentage: currentData.marketData.atlChangePercentage[baseCoin.rawValue] ?? 0.0,
                minimumValueDate: currentData.marketData.atlDate[baseCoin.rawValue] ?? Date()
            )
            presenter?.presentCoin(response: response)
        } else {
            presenter?.presentError(error: .undefinedError)
        }
    }
    
    private func createMarketChartResponse(marketChart: MarketChartModel?) {
        if let marketChart {
            let response = marketChart.prices.map { prices in
                return Coin.FetchMarketChart.Response(
                    price: prices[1],
                    dataEntry: ChartDataEntry(x: prices[0], y: prices[1])
                )
            }
            presenter?.presentMarketChart(response: response)
        } else {
            presenter?.presentError(error: .undefinedError)
        }
    }
    
    private func createOhlcResponse(graphicData: [GraphicDataModel]?) {
        if let graphicData {
            let response = graphicData.map { data in
                return Coin.FetchMarketChart.Response(
                    price: data[4],
                    dataEntry: ChartDataEntry(x: data[0], y: data[4])
                )
            }
            presenter?.presentMarketChart(response: response)
        } else {
            presenter?.presentError(error: .undefinedError)
        }
    }
}
